export const examples = [
  {
    "title": "Хороший пример - Сортировка списка товаров",
    "story": "Нужно создать библиотеку для сортировки списка товаров по различным параметрам, которая будет использоваться в интернет-магазине.",
    "requirements": "1. Создать класс Product с атрибутами: id, name, price, rating, date_added\n2. Создать функцию sort_products, которая принимает список товаров и параметр сортировки\n3. Поддерживать сортировку по цене (возрастание/убывание), рейтингу (убывание) и дате добавления (новые сначала)\n4. Функция должна возвращать новый отсортированный список, не изменяя оригинальный\n5. Добавить валидацию входных параметров\n6. Обрабатывать ошибки некорректного ввода",
    "code": "from datetime import datetime\nfrom typing import List, Dict, Any, Literal, Union, Optional\nfrom copy import deepcopy\n\nclass Product:\n    \"\"\"Класс, представляющий товар в интернет-магазине.\"\"\"\n    \n    def __init__(self, id: int, name: str, price: float, rating: float, date_added: datetime):\n        \"\"\"Инициализация нового товара.\n        \n        Args:\n            id: Уникальный идентификатор товара\n            name: Название товара\n            price: Цена товара\n            rating: Рейтинг товара (от 0 до 5)\n            date_added: Дата добавления товара\n        \"\"\"\n        if not isinstance(id, int) or id < 0:\n            raise ValueError(\"id должен быть положительным целым числом\")\n        \n        if not isinstance(name, str) or not name.strip():\n            raise ValueError(\"name должен быть непустой строкой\")\n        \n        if not isinstance(price, (int, float)) or price < 0:\n            raise ValueError(\"price должен быть положительным числом\")\n        \n        if not isinstance(rating, (int, float)) or not (0 <= rating <= 5):\n            raise ValueError(\"rating должен быть числом от 0 до 5\")\n        \n        if not isinstance(date_added, datetime):\n            raise ValueError(\"date_added должен быть объектом datetime\")\n        \n        self.id = id\n        self.name = name\n        self.price = price\n        self.rating = rating\n        self.date_added = date_added\n    \n    def __repr__(self) -> str:\n        return f\"Product(id={self.id}, name='{self.name}', price={self.price}, rating={self.rating})\"\n\n\ndef sort_products(\n    products: List[Product], \n    sort_by: Literal['price_asc', 'price_desc', 'rating', 'date'] = 'price_asc'\n) -> List[Product]:\n    \"\"\"Сортирует список товаров по указанному параметру.\n    \n    Args:\n        products: Список объектов Product для сортировки\n        sort_by: Параметр сортировки. Возможные значения:\n                'price_asc' - по возрастанию цены\n                'price_desc' - по убыванию цены\n                'rating' - по убыванию рейтинга\n                'date' - по дате добавления (новые сначала)\n    \n    Returns:\n        Новый отсортированный список товаров\n    \n    Raises:\n        ValueError: Если products не является списком объектов Product\n                   или sort_by имеет неподдерживаемое значение.\n    \"\"\"\n    if not isinstance(products, list):\n        raise ValueError(\"products должен быть списком\")\n    \n    if not all(isinstance(p, Product) for p in products):\n        raise ValueError(\"Все элементы списка должны быть объектами класса Product\")\n    \n    valid_sort_params = ['price_asc', 'price_desc', 'rating', 'date']\n    if sort_by not in valid_sort_params:\n        raise ValueError(f\"sort_by должен быть одним из {valid_sort_params}\")\n    \n    # Создаем копию списка, чтобы не изменять оригинальный\n    result = deepcopy(products)\n    \n    # Сортируем по выбранному параметру\n    if sort_by == 'price_asc':\n        result.sort(key=lambda p: p.price)\n    elif sort_by == 'price_desc':\n        result.sort(key=lambda p: p.price, reverse=True)\n    elif sort_by == 'rating':\n        result.sort(key=lambda p: p.rating, reverse=True)\n    elif sort_by == 'date':\n        result.sort(key=lambda p: p.date_added, reverse=True)\n    \n    return result",
    "test_cases": "import unittest\nfrom datetime import datetime, timedelta\nfrom product_sorter import Product, sort_products\n\nclass TestProductSorter(unittest.TestCase):\n    def setUp(self):\n        # Создаем тестовые данные\n        now = datetime.now()\n        self.products = [\n            Product(1, \"Laptop\", 1200.0, 4.5, now - timedelta(days=10)),\n            Product(2, \"Smartphone\", 800.0, 4.8, now - timedelta(days=5)),\n            Product(3, \"Headphones\", 150.0, 4.2, now - timedelta(days=20)),\n            Product(4, \"Tablet\", 500.0, 4.6, now - timedelta(days=15)),\n            Product(5, \"Monitor\", 300.0, 4.7, now)\n        ]\n    \n    def test_sort_by_price_asc(self):\n        \"\"\"Тест сортировки по возрастанию цены\"\"\"\n        sorted_products = sort_products(self.products, 'price_asc')\n        self.assertEqual(len(sorted_products), len(self.products))\n        self.assertEqual(sorted_products[0].id, 3)  # Headphones\n        self.assertEqual(sorted_products[-1].id, 1)  # Laptop\n        \n        # Проверяем, что оригинальный список не изменился\n        self.assertEqual(self.products[0].id, 1)\n    \n    def test_sort_by_price_desc(self):\n        \"\"\"Тест сортировки по убыванию цены\"\"\"\n        sorted_products = sort_products(self.products, 'price_desc')\n        self.assertEqual(sorted_products[0].id, 1)  # Laptop\n        self.assertEqual(sorted_products[-1].id, 3)  # Headphones\n    \n    def test_sort_by_rating(self):\n        \"\"\"Тест сортировки по рейтингу\"\"\"\n        sorted_products = sort_products(self.products, 'rating')\n        self.assertEqual(sorted_products[0].id, 2)  # Smartphone (4.8)\n        self.assertEqual(sorted_products[-1].id, 3)  # Headphones (4.2)\n    \n    def test_sort_by_date(self):\n        \"\"\"Тест сортировки по дате добавления\"\"\"\n        sorted_products = sort_products(self.products, 'date')\n        self.assertEqual(sorted_products[0].id, 5)  # Monitor (новейший)\n        self.assertEqual(sorted_products[-1].id, 3)  # Headphones (старейший)\n    \n    def test_default_sort(self):\n        \"\"\"Тест сортировки по умолчанию\"\"\"\n        sorted_products = sort_products(self.products)  # Без указания параметра\n        self.assertEqual(sorted_products[0].id, 3)  # Headphones\n        self.assertEqual(sorted_products[-1].id, 1)  # Laptop\n    \n    def test_invalid_sort_parameter(self):\n        \"\"\"Тест обработки неверного параметра сортировки\"\"\"\n        with self.assertRaises(ValueError):\n            sort_products(self.products, 'invalid_param')\n    \n    def test_invalid_product_list(self):\n        \"\"\"Тест обработки неверного списка товаров\"\"\"\n        with self.assertRaises(ValueError):\n            sort_products(\"not a list\", 'price_asc')\n        \n        with self.assertRaises(ValueError):\n            sort_products([\"not a product\", 123], 'price_asc')\n    \n    def test_product_validation(self):\n        \"\"\"Тест валидации параметров при создании Product\"\"\"\n        now = datetime.now()\n        \n        # Некорректный id\n        with self.assertRaises(ValueError):\n            Product(-1, \"Test\", 100, 4.5, now)\n        \n        # Некорректное имя\n        with self.assertRaises(ValueError):\n            Product(1, \"\", 100, 4.5, now)\n        \n        # Некорректная цена\n        with self.assertRaises(ValueError):\n            Product(1, \"Test\", -100, 4.5, now)\n        \n        # Некорректный рейтинг\n        with self.assertRaises(ValueError):\n            Product(1, \"Test\", 100, 6, now)\n        \n        # Некорректная дата\n        with self.assertRaises(ValueError):\n            Product(1, \"Test\", 100, 4.5, \"not a date\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "title": "Средний пример - Калькулятор скидок",
    "story": "Разрабатываем модуль для расчета скидок в системе лояльности для нашей розничной сети.",
    "requirements": "1. Создать функцию calculate_discount, которая рассчитывает скидку на основе суммы покупки и уровня лояльности клиента\n2. Поддерживать 3 уровня лояльности: 'standard', 'silver', 'gold'\n3. Скидки по уровням:\n   - 'standard': 0% до 1000 руб., 2% свыше 1000 руб.\n   - 'silver': 2% до 1000 руб., 5% от 1000 до 5000 руб., 7% свыше 5000 руб.\n   - 'gold': 5% до 1000 руб., 10% от 1000 до 5000 руб., 15% свыше 5000 руб.\n4. Предусмотреть возможность применения промокода (дополнительные 5% скидки)\n5. Максимальная скидка не должна превышать 20%",
    "code": "def calculate_discount(purchase_amount, loyalty_level='standard', promo_code=None):\n    \"\"\"Рассчитывает скидку на основе суммы покупки и уровня лояльности.\n    \n    Args:\n        purchase_amount: Сумма покупки в рублях\n        loyalty_level: Уровень лояльности клиента ('standard', 'silver', или 'gold')\n        promo_code: Промокод для дополнительной скидки\n    \n    Returns:\n        float: Сумма скидки в рублях\n    \"\"\"\n    # Проверка входных данных\n    if purchase_amount < 0:\n        raise ValueError(\"Сумма покупки не может быть отрицательной\")\n    \n    # Инициализация скидки\n    discount_percentage = 0\n    \n    # Расчет базовой скидки в зависимости от уровня лояльности и суммы покупки\n    if loyalty_level == 'standard':\n        if purchase_amount > 1000:\n            discount_percentage = 2\n    elif loyalty_level == 'silver':\n        if purchase_amount < 1000:\n            discount_percentage = 2\n        elif purchase_amount <= 5000:\n            discount_percentage = 5\n        else:\n            discount_percentage = 7\n    elif loyalty_level == 'gold':\n        if purchase_amount < 1000:\n            discount_percentage = 5\n        elif purchase_amount <= 5000:\n            discount_percentage = 10\n        else:\n            discount_percentage = 15\n    else:\n        # Обработка неверного уровня лояльности\n        raise ValueError(\"Неверный уровень лояльности. Доступные значения: 'standard', 'silver', 'gold'\")\n    \n    # Добавление скидки по промокоду\n    if promo_code is not None:\n        discount_percentage += 5\n    \n    # Ограничение максимальной скидки\n    if discount_percentage > 20:\n        discount_percentage = 20\n    \n    # Расчет суммы скидки\n    discount_amount = purchase_amount * (discount_percentage / 100)\n    \n    return discount_amount",
    "test_cases": "import unittest\nfrom discount_calculator import calculate_discount\n\nclass TestDiscountCalculator(unittest.TestCase):\n    def test_standard_level(self):\n        # Стандартный уровень, сумма покупки меньше 1000\n        self.assertEqual(calculate_discount(500, 'standard'), 0)\n        \n        # Стандартный уровень, сумма покупки больше 1000\n        self.assertEqual(calculate_discount(2000, 'standard'), 40)  # 2% от 2000 = 40\n    \n    def test_silver_level(self):\n        # Серебряный уровень, сумма покупки меньше 1000\n        self.assertEqual(calculate_discount(500, 'silver'), 10)  # 2% от 500 = 10\n        \n        # Серебряный уровень, сумма покупки между 1000 и 5000\n        self.assertEqual(calculate_discount(3000, 'silver'), 150)  # 5% от 3000 = 150\n        \n        # Серебряный уровень, сумма покупки больше 5000\n        self.assertEqual(calculate_discount(6000, 'silver'), 420)  # 7% от 6000 = 420\n    \n    def test_gold_level(self):\n        # Золотой уровень, сумма покупки меньше 1000\n        self.assertEqual(calculate_discount(800, 'gold'), 40)  # 5% от 800 = 40\n        \n        # Золотой уровень, сумма покупки между 1000 и 5000\n        self.assertEqual(calculate_discount(2500, 'gold'), 250)  # 10% от 2500 = 250\n        \n        # Золотой уровень, сумма покупки больше 5000\n        self.assertEqual(calculate_discount(8000, 'gold'), 1200)  # 15% от 8000 = 1200\n    \n    def test_promo_code(self):\n        # Проверка работы промокода\n        # Стандартный уровень с промокодом (0% + 5%)\n        self.assertEqual(calculate_discount(900, 'standard', promo_code='SALE5'), 45)  # 5% от 900 = 45\n        \n        # Серебряный уровень с промокодом (5% + 5%)\n        self.assertEqual(calculate_discount(3000, 'silver', promo_code='SALE5'), 300)  # 10% от 3000 = 300\n        \n        # Золотой уровень с промокодом (15% + 5%), но с ограничением в 20%\n        self.assertEqual(calculate_discount(8000, 'gold', promo_code='SALE5'), 1600)  # 20% от 8000 = 1600\n    \n    def test_invalid_amount(self):\n        # Проверка на отрицательную сумму покупки\n        with self.assertRaises(ValueError):\n            calculate_discount(-100, 'standard')\n            \n    def test_invalid_loyalty_level(self):\n        # Проверка на неверный уровень лояльности\n        with self.assertRaises(ValueError):\n            calculate_discount(1000, 'platinum')\n            \n    def test_default_loyalty_level(self):\n        # Проверка значения по умолчанию для уровня лояльности\n        self.assertEqual(calculate_discount(800), 0)  # стандартный уровень, до 1000 руб. - 0%\n        self.assertEqual(calculate_discount(1500), 30)  # стандартный уровень, свыше 1000 руб. - 2%\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "title": "Плохой пример - Конвертер валют",
    "story": "Нужно написать простой конвертер валют для мобильного приложения.",
    "requirements": "1. Функция convert_currency должна переводить сумму из одной валюты в другую\n2. Должны поддерживаться следующие валюты: USD, EUR, GBP, JPY, RUB\n3. Курсы валют хранятся в словаре\n4. Функция должна возвращать сумму в целевой валюте, округленную до двух знаков после запятой\n5. Добавить валидацию входных параметров\n6. Создать тесты для проверки функции",
    "code": "exchange_rates = {\n    'USD': {'EUR': 0.85, 'GBP': 0.75, 'JPY': 110.2, 'RUB': 74.12},\n    'EUR': {'USD': 1.18, 'GBP': 0.88, 'JPY': 129.5, 'RUB': 87.20},\n    'GBP': {'USD': 1.34, 'EUR': 1.14, 'JPY': 147.1, 'RUB': 99.15},\n    'JPY': {'USD': 0.009, 'EUR': 0.0077, 'GBP': 0.0068, 'RUB': 0.67},\n    'RUB': {'USD': 0.013, 'EUR': 0.011, 'GBP': 0.01, 'JPY': 1.49}\n}\n\ndef convert_currency(amount, from_currency, to_currency):\n    # Проверяем, что amount - число\n    if not isinstance(amount, (int, float)):\n        print(\"Ошибка: сумма должна быть числом\")\n        return None\n        \n    # Проверяем, что валюты поддерживаются\n    if from_currency not in exchange_rates:\n        print(f\"Ошибка: валюта {from_currency} не поддерживается\")\n        return None\n        \n    # Если конвертируем в ту же валюту, возвращаем исходную сумму\n    if from_currency == to_currency:\n        return amount\n    \n    # Проверяем, что целевая валюта поддерживается\n    if to_currency not in exchange_rates:\n        print(f\"Ошибка: валюта {to_currency} не поддерживается\")\n        return None\n    \n    # Конвертация валюты\n    if to_currency in exchange_rates[from_currency]:\n        rate = exchange_rates[from_currency][to_currency]\n    else:\n        # Этот случай не должен происходить, но на всякий случай\n        print(f\"Ошибка: не найден курс обмена между {from_currency} и {to_currency}\")\n        return None\n    \n    # Вычисляем конвертированную сумму\n    converted_amount = amount * rate\n    \n    # Возвращаем результат, округленный до двух знаков после запятой\n    return converted_amount",
    "test_cases": "# Тесты для конвертера валют\n\nimport unittest\n\nclass TestCurrencyConverter(unittest.TestCase):\n    def test_convert_usd_to_eur(self):\n        result = convert_currency(100, 'USD', 'EUR')\n        self.assertEqual(result, 85)  # 100 * 0.85 = 85\n    \n    def test_convert_eur_to_rub(self):\n        result = convert_currency(50, 'EUR', 'RUB')\n        self.assertEqual(result, 4360)  # 50 * 87.20 = 4360\n    \n    def test_same_currency(self):\n        result = convert_currency(100, 'USD', 'USD')\n        self.assertEqual(result, 100)  # Та же валюта\n    \n    def test_invalid_amount(self):\n        result = convert_currency('abc', 'USD', 'EUR')\n        self.assertIsNone(result)  # Неверная сумма\n    \n    def test_invalid_currency(self):\n        result = convert_currency(100, 'USD', 'XXX')\n        self.assertIsNone(result)  # Неверная валюта\n\n# Не запускаем тесты"
  }
]; 